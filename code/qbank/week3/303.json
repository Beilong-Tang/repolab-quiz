{
  "question_type": "code",
  "question_title": "The Surrounding area",
  "question_content": {
    "description": "### Problem03\n\n```java\npublic class SurroundArea\n{\n    public static boolean[][] visited;\n    public static int[][]direction={{1,0},{-1,0},{0,1},{0,-1}};\n    public static void solve(char[][] board) \n    {\n        \n        int height=board.length;\n        int width=board[0].length;\n        visited=new boolean[height][width];\n        for(int i =0;i<height;i++)\n        {\n            if(board[i][0]=='O')       dfs(i,0,board,height,width);\n            if(board[i][width-1]=='O') dfs(i,width-1,board,height,width);\n        }\n        for(int j =0;j<width;j++)\n        {\n            if(board[0][j]=='O')        dfs(0,j,board,height,width);\n            if(board[height-1][j]=='O') dfs(height-1,j,board,height,width);\n        }\n\n        for(int i =0;i< height;i++)\n        {\n            for (int j =0;j<width;j++)\n            {\n                if (__0__){board [i][j]='X';} \n            }\n        }\n    }\n\n    public static void dfs(int i , int j, char[][]board, int height, int width )\n    {\n        if (__1__)return;\n        visited[i][j]=true;\n        for (int[] item : direction)\n        {\n            int newx= i+item[0];\n            int newy= j+item[1];\n            if (newx<0||newy<0||newx>height-1||newy>width-1) continue;\n            if (!visited[newx][newy])\n            {\n            dfs(__2__);\n            }\n        }\n    }\n}\n```\n\nComplete all the static methods in SurroudArea.java so that when Given an m x n matrix board containing 'X' and 'O', it can capture all regions that are 4-directionally\u00a0surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.\n\nExample_1:\n//Input:\nchar[][]board={\n{'X','O','X','X'},\n{'X','O','O','O'},\n{'X','X','O','X'},\n{'X','O','X','X'},\n{'X','X','X','X'}};\nsolve(board);\n//Output:\nboard={\n{'X','O','X','X'},\n{'X','O','O','O'},\n{'X','X','O','X'},\n{'X','X','X','X'},\n{'X','X','X','X'},};\nExplanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n\nExcerpt from LeetCode (https://leetcode.cn/problems).\n",
    "code": "public class SurroundArea\n{\n    public static boolean[][] visited;\n    public static int[][]direction={{1,0},{-1,0},{0,1},{0,-1}};\n    public static void solve(char[][] board) \n    {\n        \n        int height=board.length;\n        int width=board[0].length;\n        visited=new boolean[height][width];\n        for(int i =0;i<height;i++)\n        {\n            if(board[i][0]=='O')       dfs(i,0,board,height,width);\n            if(board[i][width-1]=='O') dfs(i,width-1,board,height,width);\n        }\n        for(int j =0;j<width;j++)\n        {\n            if(board[0][j]=='O')        dfs(0,j,board,height,width);\n            if(board[height-1][j]=='O') dfs(height-1,j,board,height,width);\n        }\n\n        for(int i =0;i< height;i++)\n        {\n            for (int j =0;j<width;j++)\n            {\n                if (__0__){board [i][j]='X';} \n            }\n        }\n    }\n\n    public static void dfs(int i , int j, char[][]board, int height, int width )\n    {\n        if (__1__)return;\n        visited[i][j]=true;\n        for (int[] item : direction)\n        {\n            int newx= i+item[0];\n            int newy= j+item[1];\n            if (newx<0||newy<0||newx>height-1||newy>width-1) continue;\n            if (!visited[newx][newy])\n            {\n            dfs(__2__);\n            }\n        }\n    }\n}",
    "check": "void check(){\n    char[][]board={\n        {'X','O','X','X','X'},\n        {'X','O','O','O','X'},\n        {'X','X','X','X','O'},\n        {'X','X','O','X','O'},\n        {'X','O','X','X','X'},\n        {'X','X','O','X','X'}\n    };\n    SurroundArea.solve(board);\n    char[][]after={\n        {'X','O','X','X','X'},\n        {'X','O','O','O','X'},\n        {'X','X','X','X','O'},\n        {'X','X','X','X','O'},\n        {'X','X','X','X','X'},\n        {'X','X','O','X','X'}\n    };\n    char[][]board_1={\n        {'X','O','X','X','X'},\n        {'X','O','X','O','X'},\n        {'X','X','X','X','X'},\n        {'X','X','X','X','O'},\n        {'X','O','X','X','X'},\n        {'X','X','O','X','X'}\n    };\n    SurroundArea.solve(board_1);\n    char[][]after_1={\n        {'X','O','X','X','X'},\n        {'X','O','X','X','X'},\n        {'X','X','X','X','X'},\n        {'X','X','X','X','O'},\n        {'X','X','X','X','X'},\n        {'X','X','O','X','X'}\n    };\n    System.out.println(compare(board,after) && compare(board_1,after_1) );\n}\nboolean compare(char[][]a,char[][]b){\n        for (int i =0;i<a.length;i++){\n            for (int j =0;j<a[0].length;j++){\n                if (a[i][j]!=b[i][j]) return false;\n            }\n        }\n        return true;\n}",
    "instruction": "/open quiz-gen/SurroundArea.txt\n/open quiz-gen/check.txt\ncheck()\n/save -history quiz-gen/data.txt",
    "title": "SurroundArea",
    "quiz_type": "code",
    "import": "",
    "main_output": null,
    "answers": [
      "board[i][j]=='O' && !visited[i][j]",
      "board[i][j]=='X' || visited[i][j]==true",
      "newx,newy,board,height,width"
    ],
    "author": "Beilong Tang",
    "level": "3",
    "section": "2.3",
    "id": 303,
    "explains": "None"
  },
  "question_level": 3,
  "question_id": 303,
  "question_week": 3
}